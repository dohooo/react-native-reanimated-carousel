{"version":3,"sources":["node_modules/react-native-snap-carousel/src/utils/animations.js","node_modules/react-native-snap-carousel/src/carousel/Carousel.js","node_modules/react-native-snap-carousel/src/pagination/Pagination.style.js","node_modules/react-native-snap-carousel/src/pagination/PaginationDot.js","node_modules/react-native-snap-carousel/src/pagination/Pagination.js","node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.style.js","node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.js","node_modules/react-addons-shallow-compare/index.js","node_modules/fbjs/lib/shallowEqual.js"],"names":["IS_ANDROID","Platform","OS","getInputRangeFromIndexes","range","index","carouselProps","sizeRef","vertical","itemHeight","itemWidth","inputRange","i","length","push","defaultScrollInterpolator","outputRange","stackScrollInterpolator","tinderScrollInterpolator","IS_IOS","AnimatedFlatList","FlatList","Animated","createAnimatedComponent","AnimatedScrollView","ScrollView","IS_RTL","I18nManager","isRTL","Carousel","props","state","hideCarousel","interpolators","initialActiveItem","_getFirstItem","firstItem","_activeItem","_previousActiveItem","_previousFirstItem","_previousItemsLength","_mounted","_positions","_currentContentOffset","_canFireBeforeCallback","_canFireCallback","_scrollOffsetRef","_onScrollTriggered","_lastScrollDate","_scrollEnabled","scrollEnabled","_initPositionsAndInterpolators","bind","_renderItem","_onSnap","_onLayout","_onScroll","_onScrollBeginDrag","enableSnap","undefined","_onScrollEnd","autoplay","_onScrollEndDrag","enableMomentum","_onMomentumScrollEnd","_onTouchStart","_onTouchEnd","_onTouchRelease","_getKeyExtractor","_setScrollHandler","_ignoreNextMomentum","ViewPropTypes","console","warn","sliderWidth","error","sliderHeight","apparitionDelay","useScrollView","customAnimationType","customAnimationOptions","onScrollViewScroll","this","_firstItem","apparitionCallback","setState","startAutoplay","requestAnimationFrame","_snapToItem","_hackActiveSlideAnimation","_apparitionTimeout","setTimeout","nextProps","nextState","shouldOptimizeUpdates","shallowCompare","prevProps","itemsLength","_getCustomDataLength","nextFirstItem","nextActiveItem","hasNewSliderWidth","hasNewSliderHeight","hasNewItemWidth","hasNewItemHeight","_setScrollEnabled","onScroll","stopAutoplay","clearTimeout","_hackSlideAnimationTimeout","_enableAutoplayTimeout","_autoplayTimeout","_snapNoMomentumTimeout","_edgeItemTimeout","_lockScrollTimeout","_getDataIndex","scrollEventConfig","listener","useNativeDriver","_scrollPos","Value","argMapping","nativeEvent","contentOffset","y","x","Array","isArray","_argMapping","pop","argMap","_onScrollHandler","event","_shouldUseStackLayout","_shouldUseTinderLayout","lockScrollWhileSnapping","data","loop","inactiveSlideOpacity","inactiveSlideScale","scrollInterpolator","slideInterpolatedStyle","_shouldUseShiftLayout","activeAnimationOptions","inactiveSlideShift","layout","loopClonesPerSide","dataLength","_enableLoop","previousItems","nextItems","dataMultiplier","Math","floor","remainder","unshift","slice","concat","_needsRTLAdaptations","baseDataIndexes","dataIndexes","j","_carouselRef","_needsScrollView","scrollTo","scrollToOffset","getNode","wrappedRef","_getWrappedRef","setNativeProps","item","opposite","activeSlideAlignment","offset","_getViewportOffset","_getContainerInnerMargin","activeSlideOffset","swipeThreshold","center","_getCenter","centerOffset","start","end","lastIndex","_getCustomData","forEach","itemData","animatedValue","_index","_getCustomIndex","_shouldAnimateSlides","_shouldUseCustomAnimation","interpolator","interpolate","extrapolate","toValue","activeAnimationType","animationCommonOptions","isInteraction","parallel","easing","Easing","linear","current","next","_currentIndex","_currentDataIndex","_nextIndex","_nextDataIndex","animations","_getSlideAnimation","stopTogether","goTo","force","direction","_scrollTo","lockScrollTimeoutDuration","_releaseScroll","repositionTo","animated","specificOptions","options","callbackOffsetMargin","scrollOffset","_getScrollOffset","_getActiveItem","itemReached","_itemToSnapTo","scrollConditions","Date","now","_playCustomSlideAnimation","_onBeforeSnap","_canLockScroll","_repositionScroll","onStartShouldSetResponderCapture","_getScrollEnabled","onTouchStart","_autoplaying","pauseAutoPlay","onTouchEnd","_autoplay","onScrollBeginDrag","_scrollStartOffset","_scrollStartActive","onScrollEndDrag","onMomentumScrollEnd","autoplayDelay","_scrollEndOffset","_scrollEndActive","_snapScroll","onLayout","_onLayoutInitDone","delta","fireCallback","initial","lockScroll","onSnapToItem","onBeforeSnapToItem","_lockScroll","autoplayInterval","_autoplayInterval","setInterval","snapToNext","clearInterval","positionIndex","_getPositionIndex","newIndex","scrollPosition","layoutCardOffset","cardOffset","mainTranslateProp","secondaryTranslateProp","peekingCardsOpacity","getMainTranslateFromScale","cardIndex","scale","centerFactor","round","getSecondaryTranslateFromScale","abs","opacity","transform","rotate","zIndex","tinderAnimatedStyles","translateProp","getTranslateFromScale","centeredPosition","edgeAlignment","opacityOutputRange","reverse","stackAnimatedStyles","animatedOpacity","animatedScale","animatedTranslate","shiftAnimatedStyles","defaultAnimatedStyles","hasParallaxImages","keyExtractor","renderItem","slideStyle","animate","Component","View","animatedStyle","_getSlideInterpolatedStyle","parallaxProps","carouselRef","mainDimension","height","width","specificProps","key","style","pointerEvents","initialNumToRender","ceil","maxToRenderPerBatch","windowSize","decelerationRate","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","overScrollMode","automaticallyAdjustContentInsets","directionalLockEnabled","pinchGestureEnabled","scrollsToTop","removeClippedSubviews","inverted","containerCustomStyle","contentContainerCustomStyle","containerStyle","flexDirection","contentContainerStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","numColumns","ref","c","horizontal","scrollEventThrottle","onResponderRelease","_onStartShouldSetResponderCapture","_getComponentOverridableProps","_getComponentStaticProps","ScrollViewComponent","map","propTypes","PropTypes","array","isRequired","func","number","string","object","oneOf","bool","oneOfType","defaultProps","StyleSheet","create","sliderPagination","alignItems","justifyContent","paddingHorizontal","paddingVertical","sliderPaginationDotContainer","marginHorizontal","sliderPaginationDot","borderRadius","DEFAULT_DOT_SIZE","backgroundColor","PaginationDot","animColor","animOpacity","animTransform","active","_animate","animatedDuration","animatedFriction","animatedTension","commonProperties","duration","_shouldAnimateColor","timing","spring","friction","tension","color","inactiveColor","activeOpacity","inactiveStyle","inactiveOpacity","inactiveScale","tappable","delayPressInDot","animatedColor","dotContainerStyle","styles","dotStyle","onPress","currentRef","TouchableOpacity","accessible","delayPressIn","PureComponent","Pagination","dotColor","inactiveDotColor","dotElement","inactiveDotElement","tappableDots","activeDotIndex","dotsLength","inactiveDotOpacity","inactiveDotScale","inactiveDotStyle","renderDots","_activeDotIndex","DefaultDot","keys","isActive","React","cloneElement","accessibilityLabel","dots","element","container","overflow","image","position","resizeMode","loaderContainer","absoluteFillObject","ParallaxImage","status","_onLoad","_onError","_measureLayout","nativeProps","_container","dimensions","measureLayout","findNodeHandle","pageX","pageY","fadeDuration","onLoad","out","quad","onError","parallaxFactor","AnimatedImageComponent","other","parallaxPadding","dynamicStyles","translateX","translateY","showSpinner","spinnerColor","ActivityIndicator","size","animating","spinner","Image","shape","shallowEqual","module","exports","instance","hasOwnProperty","Object","prototype","is","objA","objB","keysA","keysB","call"],"mappings":"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","file":"static/js/0.bac5b0fe.chunk.js","sourcesContent":["import { Platform } from 'react-native';\n\nconst IS_ANDROID = Platform.OS === 'android';\n\n// Get scroll interpolator's input range from an array of slide indexes\n// Indexes are relative to the current active slide (index 0)\n// For example, using [3, 2, 1, 0, -1] will return:\n// [\n//     (index - 3) * sizeRef, // active + 3\n//     (index - 2) * sizeRef, // active + 2\n//     (index - 1) * sizeRef, // active + 1\n//     index * sizeRef, // active\n//     (index + 1) * sizeRef // active - 1\n// ]\nexport function getInputRangeFromIndexes (range, index, carouselProps) {\n    const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;\n    let inputRange = [];\n\n    for (let i = 0; i < range.length; i++) {\n        inputRange.push((index - range[i]) * sizeRef);\n    }\n\n    return inputRange;\n}\n\n// Default behavior\n// Scale and/or opacity effect\n// Based on props 'inactiveSlideOpacity' and 'inactiveSlideScale'\nexport function defaultScrollInterpolator (index, carouselProps) {\n    const range = [1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = [0, 1, 0];\n\n    return { inputRange, outputRange };\n}\nexport function defaultAnimatedStyles (index, animatedValue, carouselProps) {\n    let animatedOpacity = {};\n    let animatedScale = {};\n\n    if (carouselProps.inactiveSlideOpacity < 1) {\n        animatedOpacity = {\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideOpacity, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideScale < 1) {\n        animatedScale = {\n            transform: [{\n                scale: animatedValue.interpolate({\n                    inputRange: [0, 1],\n                    outputRange: [carouselProps.inactiveSlideScale, 1]\n                })\n            }]\n        };\n    }\n\n    return {\n        ...animatedOpacity,\n        ...animatedScale\n    };\n}\n\n// Shift animation\n// Same as the default one, but the active slide is also shifted up or down\n// Based on prop 'inactiveSlideShift'\nexport function shiftAnimatedStyles (index, animatedValue, carouselProps) {\n    let animatedOpacity = {};\n    let animatedScale = {};\n    let animatedTranslate = {};\n\n    if (carouselProps.inactiveSlideOpacity < 1) {\n        animatedOpacity = {\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideOpacity, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideScale < 1) {\n        animatedScale = {\n            scale: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideScale, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideShift !== 0) {\n        const translateProp = carouselProps.vertical ? 'translateX' : 'translateY';\n        animatedTranslate = {\n            [translateProp]: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideShift, 0]\n            })\n        };\n    }\n\n    return {\n        ...animatedOpacity,\n        transform: [\n            { ...animatedScale },\n            { ...animatedTranslate }\n        ]\n    };\n}\n\n// Stack animation\n// Imitate a deck/stack of cards (see #195)\n// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property\n// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item\n// The `elevation` property compensates for that only visually, which is not good enough\nexport function stackScrollInterpolator (index, carouselProps) {\n    const range = IS_ANDROID ?\n        [1, 0, -1, -2, -3] :\n        [3, 2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}\nexport function stackAnimatedStyles (index, animatedValue, carouselProps, cardOffset) {\n    const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;\n    const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';\n\n    const card1Scale = 0.9;\n    const card2Scale = 0.8;\n\n    cardOffset = !cardOffset && cardOffset !== 0 ? 18 : cardOffset;\n\n    const getTranslateFromScale = (cardIndex, scale) => {\n        const centerFactor = 1 / scale * cardIndex;\n        const centeredPosition = -Math.round(sizeRef * centerFactor);\n        const edgeAlignment = Math.round((sizeRef - (sizeRef * scale)) / 2);\n        const offset = Math.round(cardOffset * Math.abs(cardIndex) / scale);\n\n        return IS_ANDROID ?\n            centeredPosition - edgeAlignment - offset :\n            centeredPosition + edgeAlignment + offset;\n    };\n\n    const opacityOutputRange = carouselProps.inactiveSlideOpacity === 1 ? [1, 1, 1, 0] : [1, 0.75, 0.5, 0];\n\n    return IS_ANDROID ? {\n        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view\n        opacity: animatedValue.interpolate({\n            inputRange: [-3, -2, -1, 0],\n            outputRange: opacityOutputRange.reverse(),\n            extrapolate: 'clamp'\n        }),\n        transform: [{\n            scale: animatedValue.interpolate({\n                inputRange: [-2, -1, 0, 1],\n                outputRange: [card2Scale, card1Scale, 1, card1Scale],\n                extrapolate: 'clamp'\n            })\n        }, {\n            [translateProp]: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0, 1],\n                outputRange: [\n                    getTranslateFromScale(-3, card2Scale),\n                    getTranslateFromScale(-2, card2Scale),\n                    getTranslateFromScale(-1, card1Scale),\n                    0,\n                    sizeRef * 0.5\n                ],\n                extrapolate: 'clamp'\n            })\n        }]\n    } : {\n        zIndex: carouselProps.data.length - index,\n        opacity: animatedValue.interpolate({\n            inputRange: [0, 1, 2, 3],\n            outputRange: opacityOutputRange,\n            extrapolate: 'clamp'\n        }),\n        transform: [{\n            scale: animatedValue.interpolate({\n                inputRange: [-1, 0, 1, 2],\n                outputRange: [card1Scale, 1, card1Scale, card2Scale],\n                extrapolate: 'clamp'\n            })\n        }, {\n            [translateProp]: animatedValue.interpolate({\n                inputRange: [-1, 0, 1, 2, 3],\n                outputRange: [\n                    -sizeRef * 0.5,\n                    0,\n                    getTranslateFromScale(1, card1Scale),\n                    getTranslateFromScale(2, card2Scale),\n                    getTranslateFromScale(3, card2Scale)\n                ],\n                extrapolate: 'clamp'\n            })\n        }]\n    };\n}\n\n// Tinder animation\n// Imitate the popular Tinder layout\n// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property\n// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item\n// The `elevation` property compensates for that only visually, which is not good enough\nexport function tinderScrollInterpolator (index, carouselProps) {\n    const range = IS_ANDROID ?\n        [1, 0, -1, -2, -3] :\n        [3, 2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}\nexport function tinderAnimatedStyles (index, animatedValue, carouselProps, cardOffset) {\n    const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;\n    const mainTranslateProp = carouselProps.vertical ? 'translateY' : 'translateX';\n    const secondaryTranslateProp = carouselProps.vertical ? 'translateX' : 'translateY';\n\n    const card1Scale = 0.96;\n    const card2Scale = 0.92;\n    const card3Scale = 0.88;\n\n    const peekingCardsOpacity = IS_ANDROID ? 0.92 : 1;\n\n    cardOffset = !cardOffset && cardOffset !== 0 ? 9 : cardOffset;\n\n    const getMainTranslateFromScale = (cardIndex, scale) => {\n        const centerFactor = 1 / scale * cardIndex;\n        return -Math.round(sizeRef * centerFactor);\n    };\n\n    const getSecondaryTranslateFromScale = (cardIndex, scale) => {\n        return Math.round(cardOffset * Math.abs(cardIndex) / scale);\n    };\n\n    return IS_ANDROID ? {\n        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view\n        opacity: animatedValue.interpolate({\n            inputRange: [-3, -2, -1, 0, 1],\n            outputRange: [0, peekingCardsOpacity, peekingCardsOpacity, 1, 0],\n            extrapolate: 'clamp'\n        }),\n        transform: [{\n            scale: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0],\n                outputRange: [card3Scale, card2Scale, card1Scale, 1],\n                extrapolate: 'clamp'\n            })\n        }, {\n            rotate: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: ['0deg', '22deg'],\n                extrapolate: 'clamp'\n            })\n        }, {\n            [mainTranslateProp]: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0, 1],\n                outputRange: [\n                    getMainTranslateFromScale(-3, card3Scale),\n                    getMainTranslateFromScale(-2, card2Scale),\n                    getMainTranslateFromScale(-1, card1Scale),\n                    0,\n                    sizeRef * 1.1\n                ],\n                extrapolate: 'clamp'\n            })\n        }, {\n            [secondaryTranslateProp]: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0],\n                outputRange: [\n                    getSecondaryTranslateFromScale(-3, card3Scale),\n                    getSecondaryTranslateFromScale(-2, card2Scale),\n                    getSecondaryTranslateFromScale(-1, card1Scale),\n                    0\n                ],\n                extrapolate: 'clamp'\n            })\n        }]\n    } : {\n        zIndex: carouselProps.data.length - index,\n        opacity: animatedValue.interpolate({\n            inputRange: [-1, 0, 1, 2, 3],\n            outputRange: [0, 1, peekingCardsOpacity, peekingCardsOpacity, 0],\n            extrapolate: 'clamp'\n        }),\n        transform: [{\n            scale: animatedValue.interpolate({\n                inputRange: [0, 1, 2, 3],\n                outputRange: [1, card1Scale, card2Scale, card3Scale],\n                extrapolate: 'clamp'\n            })\n        }, {\n            rotate: animatedValue.interpolate({\n                inputRange: [-1, 0],\n                outputRange: ['-22deg', '0deg'],\n                extrapolate: 'clamp'\n            })\n        }, {\n            [mainTranslateProp]: animatedValue.interpolate({\n                inputRange: [-1, 0, 1, 2, 3],\n                outputRange: [\n                    -sizeRef * 1.1,\n                    0,\n                    getMainTranslateFromScale(1, card1Scale),\n                    getMainTranslateFromScale(2, card2Scale),\n                    getMainTranslateFromScale(3, card3Scale)\n                ],\n                extrapolate: 'clamp'\n            })\n        }, {\n            [secondaryTranslateProp]: animatedValue.interpolate({\n                inputRange: [0, 1, 2, 3],\n                outputRange: [\n                    0,\n                    getSecondaryTranslateFromScale(1, card1Scale),\n                    getSecondaryTranslateFromScale(2, card2Scale),\n                    getSecondaryTranslateFromScale(3, card3Scale)\n                ],\n                extrapolate: 'clamp'\n            })\n        }]\n    };\n}\n","import React, { Component } from 'react';\nimport { Animated, Easing, FlatList, I18nManager, Platform, ScrollView, View, ViewPropTypes } from 'react-native';\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator,\n    stackScrollInterpolator,\n    tinderScrollInterpolator,\n    defaultAnimatedStyles,\n    shiftAnimatedStyles,\n    stackAnimatedStyles,\n    tinderAnimatedStyles\n} from '../utils/animations';\n\nconst IS_IOS = Platform.OS === 'ios';\n\n// Native driver for scroll events\n// See: https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html\nconst AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nconst AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport default class Carousel extends Component {\n\n    static propTypes = {\n        data: PropTypes.array.isRequired,\n        renderItem: PropTypes.func.isRequired,\n        itemWidth: PropTypes.number, // required for horizontal carousel\n        itemHeight: PropTypes.number, // required for vertical carousel\n        sliderWidth: PropTypes.number, // required for horizontal carousel\n        sliderHeight: PropTypes.number, // required for vertical carousel\n        activeAnimationType: PropTypes.string,\n        activeAnimationOptions: PropTypes.object,\n        activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n        activeSlideOffset: PropTypes.number,\n        apparitionDelay: PropTypes.number,\n        autoplay: PropTypes.bool,\n        autoplayDelay: PropTypes.number,\n        autoplayInterval: PropTypes.number,\n        callbackOffsetMargin: PropTypes.number,\n        containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        enableMomentum: PropTypes.bool,\n        enableSnap: PropTypes.bool,\n        firstItem: PropTypes.number,\n        hasParallaxImages: PropTypes.bool,\n        inactiveSlideOpacity: PropTypes.number,\n        inactiveSlideScale: PropTypes.number,\n        inactiveSlideShift: PropTypes.number,\n        layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n        layoutCardOffset: PropTypes.number,\n        lockScrollTimeoutDuration: PropTypes.number,\n        lockScrollWhileSnapping: PropTypes.bool,\n        loop: PropTypes.bool,\n        loopClonesPerSide: PropTypes.number,\n        scrollEnabled: PropTypes.bool,\n        scrollInterpolator: PropTypes.func,\n        slideInterpolatedStyle: PropTypes.func,\n        slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        shouldOptimizeUpdates: PropTypes.bool,\n        swipeThreshold: PropTypes.number,\n        useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n        vertical: PropTypes.bool,\n        onBeforeSnapToItem: PropTypes.func,\n        onSnapToItem: PropTypes.func\n    };\n\n    static defaultProps = {\n        activeAnimationType: 'timing',\n        activeAnimationOptions: null,\n        activeSlideAlignment: 'center',\n        activeSlideOffset: 20,\n        apparitionDelay: 0,\n        autoplay: false,\n        autoplayDelay: 1000,\n        autoplayInterval: 3000,\n        callbackOffsetMargin: 5,\n        containerCustomStyle: {},\n        contentContainerCustomStyle: {},\n        enableMomentum: false,\n        enableSnap: true,\n        firstItem: 0,\n        hasParallaxImages: false,\n        inactiveSlideOpacity: 0.7,\n        inactiveSlideScale: 0.9,\n        inactiveSlideShift: 0,\n        layout: 'default',\n        lockScrollTimeoutDuration: 1000,\n        lockScrollWhileSnapping: false,\n        loop: false,\n        loopClonesPerSide: 3,\n        scrollEnabled: true,\n        slideStyle: {},\n        shouldOptimizeUpdates: true,\n        swipeThreshold: 20,\n        useScrollView: !AnimatedFlatList,\n        vertical: false\n    }\n\n    constructor (props) {\n        super(props);\n\n        this.state = {\n            hideCarousel: true,\n            interpolators: []\n        };\n\n        // The following values are not stored in the state because 'setState()' is asynchronous\n        // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n        const initialActiveItem = this._getFirstItem(props.firstItem);\n        this._activeItem = initialActiveItem;\n        this._previousActiveItem = initialActiveItem;\n        this._previousFirstItem = initialActiveItem;\n        this._previousItemsLength = initialActiveItem;\n\n        this._mounted = false;\n        this._positions = [];\n        this._currentContentOffset = 0; // store ScrollView's scroll position\n        this._canFireBeforeCallback = false;\n        this._canFireCallback = false;\n        this._scrollOffsetRef = null;\n        this._onScrollTriggered = true; // used when momentum is enabled to prevent an issue with edges items\n        this._lastScrollDate = 0; // used to work around a FlatList bug\n        this._scrollEnabled = props.scrollEnabled !== false;\n\n        this._initPositionsAndInterpolators = this._initPositionsAndInterpolators.bind(this);\n        this._renderItem = this._renderItem.bind(this);\n        this._onSnap = this._onSnap.bind(this);\n\n        this._onLayout = this._onLayout.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onScrollBeginDrag = props.enableSnap ? this._onScrollBeginDrag.bind(this) : undefined;\n        this._onScrollEnd = props.enableSnap || props.autoplay ? this._onScrollEnd.bind(this) : undefined;\n        this._onScrollEndDrag = !props.enableMomentum ? this._onScrollEndDrag.bind(this) : undefined;\n        this._onMomentumScrollEnd = props.enableMomentum ? this._onMomentumScrollEnd.bind(this) : undefined;\n        this._onTouchStart = this._onTouchStart.bind(this);\n        this._onTouchEnd = this._onTouchEnd.bind(this);\n        this._onTouchRelease = this._onTouchRelease.bind(this);\n\n        this._getKeyExtractor = this._getKeyExtractor.bind(this);\n\n        this._setScrollHandler(props);\n\n        // This bool aims at fixing an iOS bug due to scrollTo that triggers onMomentumScrollEnd.\n        // onMomentumScrollEnd fires this._snapScroll, thus creating an infinite loop.\n        this._ignoreNextMomentum = false;\n\n        // Warnings\n        if (!ViewPropTypes) {\n            console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');\n        }\n        if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');\n        }\n        if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');\n        }\n        if (props.apparitionDelay && !IS_IOS && !props.useScrollView) {\n            console.warn('react-native-snap-carousel: Using `apparitionDelay` on Android is not recommended since it can lead to rendering issues');\n        }\n        if (props.customAnimationType || props.customAnimationOptions) {\n            console.warn('react-native-snap-carousel: Props `customAnimationType` and `customAnimationOptions` have been renamed to `activeAnimationType` and `activeAnimationOptions`');\n        }\n        if (props.onScrollViewScroll) {\n            console.error('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');\n        }\n    }\n\n    componentDidMount () {\n        const { apparitionDelay, autoplay, firstItem } = this.props;\n        const _firstItem = this._getFirstItem(firstItem);\n        const apparitionCallback = () => {\n            this.setState({ hideCarousel: false });\n            if (autoplay) {\n                this.startAutoplay();\n            }\n        };\n\n        this._mounted = true;\n        this._initPositionsAndInterpolators();\n\n        // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n        requestAnimationFrame(() => {\n            if (!this._mounted) {\n                return;\n            }\n\n            this._snapToItem(_firstItem, false, false, true, false);\n            this._hackActiveSlideAnimation(_firstItem, 'start', true);\n\n            if (apparitionDelay) {\n                this._apparitionTimeout = setTimeout(() => {\n                    apparitionCallback();\n                }, apparitionDelay);\n            } else {\n                apparitionCallback();\n            }\n        });\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n        if (this.props.shouldOptimizeUpdates === false) {\n            return true;\n        } else {\n            return shallowCompare(this, nextProps, nextState);\n        }\n    }\n\n    componentDidUpdate (prevProps) {\n        const { interpolators } = this.state;\n        const { firstItem, itemHeight, itemWidth, scrollEnabled, sliderHeight, sliderWidth } = this.props;\n        const itemsLength = this._getCustomDataLength(this.props);\n\n        if (!itemsLength) {\n            return;\n        }\n\n        const nextFirstItem = this._getFirstItem(firstItem, this.props);\n        let nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;\n\n        const hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n        const hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n        const hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n        const hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n        const hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n        // Prevent issues with dynamically removed items\n        if (nextActiveItem > itemsLength - 1) {\n            nextActiveItem = itemsLength - 1;\n        }\n\n        // Handle changing scrollEnabled independent of user -> carousel interaction\n        if (hasNewScrollEnabled) {\n            this._setScrollEnabled(scrollEnabled);\n        }\n\n        if (interpolators.length !== itemsLength || hasNewSliderWidth ||\n            hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n            this._activeItem = nextActiveItem;\n            this._previousItemsLength = itemsLength;\n\n            this._initPositionsAndInterpolators(this.props);\n\n            // Handle scroll issue when dynamically removing items (see #133)\n            // This also fixes first item's active state on Android\n            // Because 'initialScrollIndex' apparently doesn't trigger scroll\n            if (this._previousItemsLength > itemsLength) {\n                this._hackActiveSlideAnimation(nextActiveItem, null, true);\n            }\n\n            if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n                this._snapToItem(nextActiveItem, false, false, false, false);\n            }\n        } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n            this._activeItem = nextFirstItem;\n            this._previousFirstItem = nextFirstItem;\n            this._snapToItem(nextFirstItem, false, true, false, false);\n        }\n\n        if (this.props.onScroll !== prevProps.onScroll) {\n          this._setScrollHandler(this.props);\n        }\n    }\n\n    componentWillUnmount () {\n        this._mounted = false;\n        this.stopAutoplay();\n        clearTimeout(this._apparitionTimeout);\n        clearTimeout(this._hackSlideAnimationTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._snapNoMomentumTimeout);\n        clearTimeout(this._edgeItemTimeout);\n        clearTimeout(this._lockScrollTimeout);\n    }\n\n    get realIndex () {\n        return this._activeItem;\n    }\n\n    get currentIndex () {\n        return this._getDataIndex(this._activeItem);\n    }\n\n    get currentScrollPosition () {\n        return this._currentContentOffset;\n    }\n\n    _setScrollHandler(props) {\n      // Native driver for scroll events\n      const scrollEventConfig = {\n        listener: this._onScroll,\n        useNativeDriver: true,\n      };\n      this._scrollPos = new Animated.Value(0);\n      const argMapping = props.vertical\n        ? [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }]\n        : [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n        // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n        argMapping.pop();\n        const [ argMap ] = props.onScroll._argMapping;\n        if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n          // Shares the same animated value passed in props\n          this._scrollPos =\n            argMap.nativeEvent.contentOffset.x ||\n            argMap.nativeEvent.contentOffset.y ||\n            this._scrollPos;\n        }\n        argMapping.push(...props.onScroll._argMapping);\n      }\n      this._onScrollHandler = Animated.event(\n        argMapping,\n        scrollEventConfig\n      );\n    }\n\n    _needsScrollView () {\n        const { useScrollView } = this.props;\n        return useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n\n    _needsRTLAdaptations () {\n        const { vertical } = this.props;\n        return IS_RTL && !IS_IOS && !vertical;\n    }\n\n    _canLockScroll () {\n        const { scrollEnabled, enableMomentum, lockScrollWhileSnapping } = this.props;\n        return scrollEnabled && !enableMomentum && lockScrollWhileSnapping;\n    }\n\n    _enableLoop () {\n        const { data, enableSnap, loop } = this.props;\n        return enableSnap && loop && data && data.length && data.length > 1;\n    }\n\n    _shouldAnimateSlides (props = this.props) {\n        const { inactiveSlideOpacity, inactiveSlideScale, scrollInterpolator, slideInterpolatedStyle } = props;\n        return inactiveSlideOpacity < 1 ||\n            inactiveSlideScale < 1 ||\n            !!scrollInterpolator ||\n            !!slideInterpolatedStyle ||\n            this._shouldUseShiftLayout() ||\n            this._shouldUseStackLayout() ||\n            this._shouldUseTinderLayout();\n    }\n\n    _shouldUseCustomAnimation () {\n        const { activeAnimationOptions } = this.props;\n        return !!activeAnimationOptions && !this._shouldUseStackLayout() && !this._shouldUseTinderLayout();\n    }\n\n    _shouldUseShiftLayout () {\n        const { inactiveSlideShift, layout } = this.props;\n        return layout === 'default' && inactiveSlideShift !== 0;\n    }\n\n    _shouldUseStackLayout () {\n        return this.props.layout === 'stack';\n    }\n\n    _shouldUseTinderLayout () {\n        return this.props.layout === 'tinder';\n    }\n\n    _getCustomData (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return [];\n        }\n\n        if (!this._enableLoop()) {\n            return data;\n        }\n\n        let previousItems = [];\n        let nextItems = [];\n\n        if (loopClonesPerSide > dataLength) {\n            const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n            const remainder = loopClonesPerSide % dataLength;\n\n            for (let i = 0; i < dataMultiplier; i++) {\n                previousItems.push(...data);\n                nextItems.push(...data);\n            }\n\n            previousItems.unshift(...data.slice(-remainder));\n            nextItems.push(...data.slice(0, remainder));\n        } else {\n            previousItems = data.slice(-loopClonesPerSide);\n            nextItems = data.slice(0, loopClonesPerSide);\n        }\n\n        return previousItems.concat(data, nextItems);\n    }\n\n    _getCustomDataLength (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return 0;\n        }\n\n        return this._enableLoop() ? dataLength + (2 * loopClonesPerSide) : dataLength;\n    }\n\n    _getCustomIndex (index, props = this.props) {\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || (!index && index !== 0)) {\n            return 0;\n        }\n\n        return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n\n    _getDataIndex (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength) {\n            return index;\n        }\n\n        if (index >= dataLength + loopClonesPerSide) {\n            return loopClonesPerSide > dataLength ?\n                (index - loopClonesPerSide) % dataLength :\n                index - dataLength - loopClonesPerSide;\n        } else if (index < loopClonesPerSide) {\n            // TODO: is there a simpler way of determining the interpolated index?\n            if (loopClonesPerSide > dataLength) {\n                const baseDataIndexes = [];\n                const dataIndexes = [];\n                const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n                const remainder = loopClonesPerSide % dataLength;\n\n                for (let i = 0; i < dataLength; i++) {\n                    baseDataIndexes.push(i);\n                }\n\n                for (let j = 0; j < dataMultiplier; j++) {\n                    dataIndexes.push(...baseDataIndexes);\n                }\n\n                dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n                return dataIndexes[index];\n            } else {\n                return index + dataLength - loopClonesPerSide;\n            }\n        } else {\n            return index - loopClonesPerSide;\n        }\n    }\n\n    // Used with `snapToItem()` and 'PaginationDot'\n    _getPositionIndex (index) {\n        const { loop, loopClonesPerSide } = this.props;\n        return loop ? index + loopClonesPerSide : index;\n    }\n\n    _getFirstItem (index, props = this.props) {\n        const { loopClonesPerSide } = props;\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || index > itemsLength - 1 || index < 0) {\n            return 0;\n        }\n\n        return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n\n    _getWrappedRef () {\n        if (this._carouselRef && (\n            (this._needsScrollView() && this._carouselRef.scrollTo) ||\n            (!this._needsScrollView() && this._carouselRef.scrollToOffset)\n        )) {\n            return this._carouselRef;\n        }\n        // https://github.com/facebook/react-native/issues/10635\n        // https://stackoverflow.com/a/48786374/8412141\n        return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n\n    _getScrollEnabled () {\n        return this._scrollEnabled;\n    }\n\n    _setScrollEnabled (scrollEnabled = true) {\n        const wrappedRef = this._getWrappedRef();\n\n        if (!wrappedRef || !wrappedRef.setNativeProps) {\n            return;\n        }\n\n        // 'setNativeProps()' is used instead of 'setState()' because the latter\n        // really takes a toll on Android behavior when momentum is disabled\n        wrappedRef.setNativeProps({ scrollEnabled });\n        this._scrollEnabled = scrollEnabled;\n    }\n\n    _getKeyExtractor (item, index) {\n        return this._needsScrollView() ? `scrollview-item-${index}` : `flatlist-item-${index}`;\n    }\n\n    _getScrollOffset (event) {\n        const { vertical } = this.props;\n        return (event && event.nativeEvent && event.nativeEvent.contentOffset &&\n            event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) || 0;\n    }\n\n    _getContainerInnerMargin (opposite = false) {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if ((activeSlideAlignment === 'start' && !opposite) ||\n            (activeSlideAlignment === 'end' && opposite)) {\n            return 0;\n        } else if ((activeSlideAlignment === 'end' && !opposite) ||\n            (activeSlideAlignment === 'start' && opposite)) {\n            return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n        } else {\n            return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n        }\n    }\n\n    _getViewportOffset () {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if (activeSlideAlignment === 'start') {\n            return vertical ? itemHeight / 2 : itemWidth / 2;\n        } else if (activeSlideAlignment === 'end') {\n            return vertical ?\n                sliderHeight - (itemHeight / 2) :\n                sliderWidth - (itemWidth / 2);\n        } else {\n            return vertical ? sliderHeight / 2 : sliderWidth / 2;\n        }\n    }\n\n    _getCenter (offset) {\n        return offset + this._getViewportOffset() - this._getContainerInnerMargin();\n    }\n\n    _getActiveItem (offset) {\n        const { activeSlideOffset, swipeThreshold } = this.props;\n        const center = this._getCenter(offset);\n        const centerOffset = activeSlideOffset || swipeThreshold;\n\n        for (let i = 0; i < this._positions.length; i++) {\n            const { start, end } = this._positions[i];\n            if (center + centerOffset >= start && center - centerOffset <= end) {\n                return i;\n            }\n        }\n\n        const lastIndex = this._positions.length - 1;\n        if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {\n            return lastIndex;\n        }\n\n        return 0;\n    }\n\n    _initPositionsAndInterpolators (props = this.props) {\n        const { data, itemWidth, itemHeight, scrollInterpolator, vertical } = props;\n        const sizeRef = vertical ? itemHeight : itemWidth;\n\n        if (!data || !data.length) {\n            return;\n        }\n\n        let interpolators = [];\n        this._positions = [];\n\n        this._getCustomData(props).forEach((itemData, index) => {\n            const _index = this._getCustomIndex(index, props);\n            let animatedValue;\n\n            this._positions[index] = {\n                start: index * sizeRef,\n                end: index * sizeRef + sizeRef\n            };\n\n            if (!this._shouldAnimateSlides(props)) {\n                animatedValue = new Animated.Value(1);\n            } else if (this._shouldUseCustomAnimation()) {\n                animatedValue = new Animated.Value(_index === this._activeItem ? 1 : 0);\n            } else {\n                let interpolator;\n\n                if (scrollInterpolator) {\n                    interpolator = scrollInterpolator(_index, props);\n                } else if (this._shouldUseStackLayout()) {\n                    interpolator = stackScrollInterpolator(_index, props);\n                } else if (this._shouldUseTinderLayout()) {\n                    interpolator = tinderScrollInterpolator(_index, props);\n                }\n\n                if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n                    interpolator = defaultScrollInterpolator(_index, props);\n                }\n\n                animatedValue = this._scrollPos.interpolate({\n                    ...interpolator,\n                    extrapolate: 'clamp'\n                });\n            }\n\n            interpolators.push(animatedValue);\n        });\n\n        this.setState({ interpolators });\n    }\n\n    _getSlideAnimation (index, toValue) {\n        const { interpolators } = this.state;\n        const { activeAnimationType, activeAnimationOptions } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animationCommonOptions = {\n            isInteraction: false,\n            useNativeDriver: true,\n            ...activeAnimationOptions,\n            toValue: toValue\n        };\n\n        return Animated.parallel([\n            Animated['timing'](\n                animatedValue,\n                { ...animationCommonOptions, easing: Easing.linear }\n            ),\n            Animated[activeAnimationType](\n                animatedValue,\n                { ...animationCommonOptions }\n            )\n        ]);\n    }\n\n    _playCustomSlideAnimation (current, next) {\n        const { interpolators } = this.state;\n        const itemsLength = this._getCustomDataLength();\n        const _currentIndex = this._getCustomIndex(current);\n        const _currentDataIndex = this._getDataIndex(_currentIndex);\n        const _nextIndex = this._getCustomIndex(next);\n        const _nextDataIndex = this._getDataIndex(_nextIndex);\n        let animations = [];\n\n        // Keep animations in sync when looping\n        if (this._enableLoop()) {\n            for (let i = 0; i < itemsLength; i++) {\n                if (this._getDataIndex(i) === _currentDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 0));\n                } else if (this._getDataIndex(i) === _nextDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 1));\n                }\n            }\n        } else {\n            if (interpolators[current]) {\n                animations.push(this._getSlideAnimation(current, 0));\n            }\n            if (interpolators[next]) {\n                animations.push(this._getSlideAnimation(next, 1));\n            }\n        }\n\n        Animated.parallel(animations, { stopTogether: false }).start();\n    }\n\n    _hackActiveSlideAnimation (index, goTo, force = false) {\n        const { data } = this.props;\n\n        if (!this._mounted || !this._carouselRef || !this._positions[index] || (!force && this._enableLoop())) {\n            return;\n        }\n\n        const offset = this._positions[index] && this._positions[index].start;\n\n        if (!offset && offset !== 0) {\n            return;\n        }\n\n        const itemsLength = data && data.length;\n        const direction = goTo || itemsLength === 1 ? 'start' : 'end';\n\n        this._scrollTo(offset + (direction === 'start' ? -1 : 1), false);\n\n        clearTimeout(this._hackSlideAnimationTimeout);\n        this._hackSlideAnimationTimeout = setTimeout(() => {\n            this._scrollTo(offset, false);\n        }, 50); // works randomly when set to '0'\n    }\n\n    _lockScroll () {\n        const { lockScrollTimeoutDuration } = this.props;\n        clearTimeout(this._lockScrollTimeout);\n        this._lockScrollTimeout = setTimeout(() => {\n            this._releaseScroll();\n        }, lockScrollTimeoutDuration);\n        this._setScrollEnabled(false);\n    }\n\n    _releaseScroll () {\n        clearTimeout(this._lockScrollTimeout);\n        this._setScrollEnabled(true);\n    }\n\n    _repositionScroll (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength ||\n            (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)) {\n            return;\n        }\n\n        let repositionTo = index;\n\n        if (index >= dataLength + loopClonesPerSide) {\n            repositionTo = index - dataLength;\n        } else if (index < loopClonesPerSide) {\n            repositionTo = index + dataLength;\n        }\n\n        this._snapToItem(repositionTo, false, false, false, false);\n    }\n\n    _scrollTo (offset, animated = true) {\n        const { vertical } = this.props;\n        const wrappedRef = this._getWrappedRef();\n\n        if (!this._mounted || !wrappedRef) {\n            return;\n        }\n\n        const specificOptions = this._needsScrollView() ? {\n            x: vertical ? 0 : offset,\n            y: vertical ? offset : 0\n        } : {\n            offset\n        };\n        const options = {\n            ...specificOptions,\n            animated\n        };\n\n        if (this._needsScrollView()) {\n            wrappedRef.scrollTo(options);\n        } else {\n            wrappedRef.scrollToOffset(options);\n        }\n    }\n\n    _onScroll (event) {\n        const { callbackOffsetMargin, enableMomentum, onScroll } = this.props;\n\n        const scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;\n        const nextActiveItem = this._getActiveItem(scrollOffset);\n        const itemReached = nextActiveItem === this._itemToSnapTo;\n        const scrollConditions =\n            scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin &&\n            scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;\n\n        this._currentContentOffset = scrollOffset;\n        this._onScrollTriggered = true;\n        this._lastScrollDate = Date.now();\n\n        if (this._activeItem !== nextActiveItem && this._shouldUseCustomAnimation()) {\n            this._playCustomSlideAnimation(this._activeItem, nextActiveItem);\n        }\n\n        if (enableMomentum) {\n            clearTimeout(this._snapNoMomentumTimeout);\n\n            if (this._activeItem !== nextActiveItem) {\n                this._activeItem = nextActiveItem;\n            }\n\n            if (itemReached) {\n                if (this._canFireBeforeCallback) {\n                    this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n                }\n\n                if (scrollConditions && this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        } else if (this._activeItem !== nextActiveItem && itemReached) {\n            if (this._canFireBeforeCallback) {\n                this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n            }\n\n            if (scrollConditions) {\n                this._activeItem = nextActiveItem;\n\n                if (this._canLockScroll()) {\n                    this._releaseScroll();\n                }\n\n                if (this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        }\n\n        if (nextActiveItem === this._itemToSnapTo &&\n            scrollOffset === this._scrollOffsetRef) {\n            this._repositionScroll(nextActiveItem);\n        }\n\n        if (typeof onScroll === \"function\" && event) {\n            onScroll(event);\n        }\n    }\n\n    _onStartShouldSetResponderCapture (event) {\n        const { onStartShouldSetResponderCapture } = this.props;\n\n        if (onStartShouldSetResponderCapture) {\n            onStartShouldSetResponderCapture(event);\n        }\n\n        return this._getScrollEnabled();\n    }\n\n    _onTouchStart () {\n        const { onTouchStart } = this.props\n\n        // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n        if (this._getScrollEnabled() !== false && this._autoplaying) {\n            this.pauseAutoPlay();\n        }\n\n        if (onTouchStart) {\n            onTouchStart()\n        }\n    }\n\n    _onTouchEnd () {\n        const { onTouchEnd } = this.props\n\n        if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n            // This event is buggy on Android, so a fallback is provided in _onScrollEnd()\n            this.startAutoplay();\n        }\n\n        if (onTouchEnd) {\n            onTouchEnd()\n        }\n    }\n\n    // Used when `enableSnap` is ENABLED\n    _onScrollBeginDrag (event) {\n        const { onScrollBeginDrag } = this.props;\n\n        if (!this._getScrollEnabled()) {\n            return;\n        }\n\n        this._scrollStartOffset = this._getScrollOffset(event);\n        this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);\n        this._ignoreNextMomentum = false;\n        // this._canFireCallback = false;\n\n        if (onScrollBeginDrag) {\n            onScrollBeginDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is DISABLED\n    _onScrollEndDrag (event) {\n        const { onScrollEndDrag } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onScrollEndDrag) {\n            onScrollEndDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is ENABLED\n    _onMomentumScrollEnd (event) {\n        const { onMomentumScrollEnd } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onMomentumScrollEnd) {\n            onMomentumScrollEnd(event);\n        }\n    }\n\n    _onScrollEnd (event) {\n        const { autoplayDelay, enableSnap } = this.props;\n\n        if (this._ignoreNextMomentum) {\n            // iOS fix\n            this._ignoreNextMomentum = false;\n            return;\n        }\n\n        if (this._currentContentOffset === this._scrollEndOffset) {\n            return;\n        }\n\n        this._scrollEndOffset = this._currentContentOffset;\n        this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);\n\n        if (enableSnap) {\n            this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);\n        }\n\n        // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n        // https://github.com/facebook/react-native/issues/9439\n        if (this._autoplay && !this._autoplaying) {\n            clearTimeout(this._enableAutoplayTimeout);\n            this._enableAutoplayTimeout = setTimeout(() => {\n                this.startAutoplay();\n            }, autoplayDelay + 50);\n        }\n    }\n\n    // Due to a bug, this event is only fired on iOS\n    // https://github.com/facebook/react-native/issues/6791\n    // it's fine since we're only fixing an iOS bug in it, so ...\n    _onTouchRelease (event) {\n        const { enableMomentum } = this.props;\n\n        if (enableMomentum && IS_IOS) {\n            clearTimeout(this._snapNoMomentumTimeout);\n            this._snapNoMomentumTimeout = setTimeout(() => {\n                this._snapToItem(this._activeItem);\n            }, 100);\n        }\n    }\n\n    _onLayout (event) {\n        const { onLayout } = this.props;\n\n        // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n        if (this._onLayoutInitDone) {\n            this._initPositionsAndInterpolators();\n            this._snapToItem(this._activeItem, false, false, false, false);\n        } else {\n            this._onLayoutInitDone = true;\n        }\n\n        if (onLayout) {\n            onLayout(event);\n        }\n    }\n\n    _snapScroll (delta) {\n        const { swipeThreshold } = this.props;\n\n        // When using momentum and releasing the touch with\n        // no velocity, scrollEndActive will be undefined (iOS)\n        if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {\n            this._scrollEndActive = this._scrollStartActive;\n        }\n\n        if (this._scrollStartActive !== this._scrollEndActive) {\n            // Snap to the new active item\n            this._snapToItem(this._scrollEndActive);\n        } else {\n            // Snap depending on delta\n            if (delta > 0) {\n                if (delta > swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive + 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else if (delta < 0) {\n                if (delta < -swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive - 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else {\n                // Snap to current\n                this._snapToItem(this._scrollEndActive);\n            }\n        }\n    }\n\n    _snapToItem (index, animated = true, fireCallback = true, initial = false, lockScroll = true) {\n        const { enableMomentum, onSnapToItem, onBeforeSnapToItem } = this.props;\n        const itemsLength = this._getCustomDataLength();\n        const wrappedRef = this._getWrappedRef();\n\n        if (!itemsLength || !wrappedRef) {\n            return;\n        }\n\n        if (!index || index < 0) {\n            index = 0;\n        } else if (itemsLength > 0 && index >= itemsLength) {\n            index = itemsLength - 1;\n        }\n\n        if (index !== this._previousActiveItem) {\n            this._previousActiveItem = index;\n\n            // Placed here to allow overscrolling for edges items\n            if (lockScroll && this._canLockScroll()) {\n                this._lockScroll();\n            }\n\n            if (fireCallback) {\n                if (onBeforeSnapToItem) {\n                    this._canFireBeforeCallback = true;\n                }\n\n                if (onSnapToItem) {\n                    this._canFireCallback = true;\n                }\n            }\n        }\n\n        this._itemToSnapTo = index;\n        this._scrollOffsetRef = this._positions[index] && this._positions[index].start;\n        this._onScrollTriggered = false;\n\n        if (!this._scrollOffsetRef && this._scrollOffsetRef !== 0) {\n            return;\n        }\n\n        this._scrollTo(this._scrollOffsetRef, animated);\n\n        this._scrollEndOffset = this._currentContentOffset;\n\n        if (enableMomentum) {\n            // iOS fix, check the note in the constructor\n            if (!initial) {\n                this._ignoreNextMomentum = true;\n            }\n\n            // When momentum is enabled and the user is overscrolling or swiping very quickly,\n            // 'onScroll' is not going to be triggered for edge items. Then callback won't be\n            // fired and loop won't work since the scrollview is not going to be repositioned.\n            // As a workaround, '_onScroll()' will be called manually for these items if a given\n            // condition hasn't been met after a small delay.\n            // WARNING: this is ok only when relying on 'momentumScrollEnd', not with 'scrollEndDrag'\n            if (index === 0 || index === itemsLength - 1) {\n                clearTimeout(this._edgeItemTimeout);\n                this._edgeItemTimeout = setTimeout(() => {\n                    if (!initial && index === this._activeItem && !this._onScrollTriggered) {\n                        this._onScroll();\n                    }\n                }, 250);\n            }\n        }\n    }\n\n    _onBeforeSnap (index) {\n        const { onBeforeSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireBeforeCallback = false;\n        onBeforeSnapToItem && onBeforeSnapToItem(index);\n    }\n\n    _onSnap (index) {\n        const { onSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireCallback = false;\n        onSnapToItem && onSnapToItem(index);\n    }\n\n    startAutoplay () {\n        const { autoplayInterval, autoplayDelay } = this.props;\n        this._autoplay = true;\n\n        if (this._autoplaying) {\n            return;\n        }\n\n        clearTimeout(this._autoplayTimeout);\n        this._autoplayTimeout = setTimeout(() => {\n            this._autoplaying = true;\n            this._autoplayInterval = setInterval(() => {\n                if (this._autoplaying) {\n                    this.snapToNext();\n                }\n            }, autoplayInterval);\n        }, autoplayDelay);\n    }\n\n    pauseAutoPlay () {\n        this._autoplaying = false;\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearInterval(this._autoplayInterval);\n    }\n\n    stopAutoplay () {\n        this._autoplay = false;\n        this.pauseAutoPlay();\n    }\n\n    snapToItem (index, animated = true, fireCallback = true) {\n        if (!index || index < 0) {\n            index = 0;\n        }\n\n        const positionIndex = this._getPositionIndex(index);\n\n        if (positionIndex === this._activeItem) {\n            return;\n        }\n\n        this._snapToItem(positionIndex, animated, fireCallback);\n    }\n\n    snapToNext (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem + 1;\n        if (newIndex > itemsLength - 1) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = 0;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    snapToPrev (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem - 1;\n        if (newIndex < 0) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = itemsLength - 1;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n    triggerRenderingHack (offset) {\n        // Avoid messing with user scroll\n        if (Date.now() - this._lastScrollDate < 500) {\n            return;\n        }\n\n        const scrollPosition = this._currentContentOffset;\n        if (!scrollPosition && scrollPosition !== 0) {\n            return;\n        }\n\n        const scrollOffset = offset || (scrollPosition === 0 ? 1 : -1);\n        this._scrollTo(scrollPosition + scrollOffset, false);\n    }\n\n    _getSlideInterpolatedStyle (index, animatedValue) {\n        const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n        if (slideInterpolatedStyle) {\n            return slideInterpolatedStyle(index, animatedValue, this.props);\n        } else if (this._shouldUseTinderLayout()) {\n            return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseStackLayout()) {\n            return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseShiftLayout()) {\n            return shiftAnimatedStyles(index, animatedValue, this.props);\n        } else {\n            return defaultAnimatedStyles(index, animatedValue, this.props);\n        }\n    }\n\n    _renderItem ({ item, index }) {\n        const { interpolators } = this.state;\n        const {\n            hasParallaxImages,\n            itemWidth,\n            itemHeight,\n            keyExtractor,\n            renderItem,\n            sliderHeight,\n            sliderWidth,\n            slideStyle,\n            vertical\n        } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animate = this._shouldAnimateSlides();\n        const Component = animate ? Animated.View : View;\n        const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n\n        const parallaxProps = hasParallaxImages ? {\n            scrollPosition: this._scrollPos,\n            carouselRef: this._carouselRef,\n            vertical,\n            sliderWidth,\n            sliderHeight,\n            itemWidth,\n            itemHeight\n        } : undefined;\n\n        const mainDimension = vertical ? { height: itemHeight } : { width: itemWidth };\n        const specificProps = this._needsScrollView() ? {\n            key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n        } : {};\n\n        return (\n            <Component style={[mainDimension, slideStyle, animatedStyle]} pointerEvents={'box-none'} {...specificProps}>\n                { renderItem({ item, index }, parallaxProps) }\n            </Component>\n        );\n    }\n\n    _getComponentOverridableProps () {\n        const {\n            enableMomentum,\n            itemWidth,\n            itemHeight,\n            loopClonesPerSide,\n            sliderWidth,\n            sliderHeight,\n            vertical\n        } = this.props;\n\n        const visibleItems = Math.ceil(vertical ?\n            sliderHeight / itemHeight :\n            sliderWidth / itemWidth) + 1;\n        const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n        const initialNumToRender = visibleItems + (initialNumPerSide * 2);\n        const maxToRenderPerBatch = 1 + (initialNumToRender * 2);\n        const windowSize = maxToRenderPerBatch;\n\n        const specificProps = !this._needsScrollView() ? {\n            initialNumToRender: initialNumToRender,\n            maxToRenderPerBatch: maxToRenderPerBatch,\n            windowSize: windowSize\n            // updateCellsBatchingPeriod\n        } : {};\n\n        return {\n            decelerationRate: enableMomentum ? 0.9 : 'fast',\n            showsHorizontalScrollIndicator: false,\n            showsVerticalScrollIndicator: false,\n            overScrollMode: 'never',\n            automaticallyAdjustContentInsets: false,\n            directionalLockEnabled: true,\n            pinchGestureEnabled: false,\n            scrollsToTop: false,\n            removeClippedSubviews: !this._needsScrollView(),\n            inverted: this._needsRTLAdaptations(),\n            // renderToHardwareTextureAndroid: true,\n            ...specificProps\n        };\n    }\n\n    _getComponentStaticProps () {\n        const { hideCarousel } = this.state;\n        const {\n            containerCustomStyle,\n            contentContainerCustomStyle,\n            keyExtractor,\n            sliderWidth,\n            sliderHeight,\n            style,\n            vertical\n        } = this.props;\n\n        const containerStyle = [\n            containerCustomStyle || style || {},\n            hideCarousel ? { opacity: 0 } : {},\n            vertical ?\n                { height: sliderHeight, flexDirection: 'column' } :\n                // LTR hack; see https://github.com/facebook/react-native/issues/11960\n                // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n                { width: sliderWidth, flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row' }\n        ];\n        const contentContainerStyle = [\n            vertical ? {\n                paddingTop: this._getContainerInnerMargin(),\n                paddingBottom: this._getContainerInnerMargin(true)\n            } : {\n                paddingLeft: this._getContainerInnerMargin(),\n                paddingRight: this._getContainerInnerMargin(true)\n            },\n            contentContainerCustomStyle || {}\n        ];\n\n        const specificProps = !this._needsScrollView() ? {\n            // extraData: this.state,\n            renderItem: this._renderItem,\n            numColumns: 1,\n            keyExtractor: keyExtractor || this._getKeyExtractor\n        } : {};\n\n        return {\n            ref: c => this._carouselRef = c,\n            data: this._getCustomData(),\n            style: containerStyle,\n            contentContainerStyle: contentContainerStyle,\n            horizontal: !vertical,\n            scrollEventThrottle: 1,\n            onScroll: this._onScrollHandler,\n            onScrollBeginDrag: this._onScrollBeginDrag,\n            onScrollEndDrag: this._onScrollEndDrag,\n            onMomentumScrollEnd: this._onMomentumScrollEnd,\n            onResponderRelease: this._onTouchRelease,\n            onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,\n            onTouchStart: this._onTouchStart,\n            onTouchEnd: this._onScrollEnd,\n            onLayout: this._onLayout,\n            ...specificProps\n        };\n    }\n\n    render () {\n        const { data, renderItem, useScrollView } = this.props;\n\n        if (!data || !renderItem) {\n            return null;\n        }\n\n        const props = {\n            ...this._getComponentOverridableProps(),\n            ...this.props,\n            ...this._getComponentStaticProps()\n        };\n\n        const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView\n\n        return this._needsScrollView() ? (\n            <ScrollViewComponent {...props}>\n                {\n                    this._getCustomData().map((item, index) => {\n                        return this._renderItem({ item, index });\n                    })\n                }\n            </ScrollViewComponent>\n        ) : (\n            <AnimatedFlatList {...props} />\n        );\n    }\n}\n","import { StyleSheet } from 'react-native';\n\nconst DEFAULT_DOT_SIZE = 7;\nconst DEFAULT_DOT_COLOR = 'rgba(0, 0, 0, 0.75)';\n\nexport default StyleSheet.create({\n    sliderPagination: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingHorizontal: 20,\n        paddingVertical: 30\n    },\n    sliderPaginationDotContainer: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        marginHorizontal: 8\n    },\n    sliderPaginationDot: {\n        width: DEFAULT_DOT_SIZE,\n        height: DEFAULT_DOT_SIZE,\n        borderRadius: DEFAULT_DOT_SIZE / 2,\n        backgroundColor: DEFAULT_DOT_COLOR\n    }\n});\n","import React, { PureComponent } from 'react';\nimport { View, Animated, Easing, TouchableOpacity, ViewPropTypes } from 'react-native';\nimport PropTypes from 'prop-types';\nimport styles from './Pagination.style';\n\nexport default class PaginationDot extends PureComponent {\n\n    static propTypes = {\n        inactiveOpacity: PropTypes.number.isRequired,\n        inactiveScale: PropTypes.number.isRequired,\n        active: PropTypes.bool,\n        activeOpacity: PropTypes.number,\n        carouselRef: PropTypes.object,\n        color: PropTypes.string,\n        containerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        inactiveColor: PropTypes.string,\n        inactiveStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        index: PropTypes.number,\n        style: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        tappable: PropTypes.bool\n    };\n\n    constructor (props) {\n        super(props);\n        this.state = {\n            animColor: new Animated.Value(0),\n            animOpacity: new Animated.Value(0),\n            animTransform: new Animated.Value(0)\n        };\n    }\n\n    componentDidMount () {\n        if (this.props.active) {\n            this._animate(1);\n        }\n    }\n\n    componentDidUpdate (prevProps) {\n        if (prevProps.active !== this.props.active) {\n            this._animate(this.props.active ? 1 : 0);\n        }\n    }\n\n    _animate (toValue = 0) {\n        const { animColor, animOpacity, animTransform } = this.state;\n        const { animatedDuration, animatedFriction, animatedTension } = this.props\n\n        const commonProperties = {\n            toValue,\n            duration: animatedDuration,\n            isInteraction: false,\n            useNativeDriver: !this._shouldAnimateColor\n        };\n\n        let animations = [\n            Animated.timing(animOpacity, {\n                easing: Easing.linear,\n                ...commonProperties\n            }),\n            Animated.spring(animTransform, {\n                friction: animatedFriction,\n                tension: animatedTension,\n                ...commonProperties\n            })\n        ];\n\n        if (this._shouldAnimateColor) {\n            animations.push(Animated.timing(animColor, {\n                easing: Easing.linear,\n                ...commonProperties\n            }));\n        }\n\n        Animated.parallel(animations).start();\n    }\n\n    get _shouldAnimateColor () {\n        const { color, inactiveColor } = this.props;\n        return color && inactiveColor;\n    }\n\n    render () {\n        const { animColor, animOpacity, animTransform } = this.state;\n        const {\n            active,\n            activeOpacity,\n            carouselRef,\n            color,\n            containerStyle,\n            inactiveColor,\n            inactiveStyle,\n            inactiveOpacity,\n            inactiveScale,\n            index,\n            style,\n            tappable,\n            delayPressInDot\n        } = this.props;\n\n        const animatedStyle = {\n            opacity: animOpacity.interpolate({\n                inputRange: [0, 1],\n                outputRange: [inactiveOpacity, 1]\n            }),\n            transform: [{\n                scale: animTransform.interpolate({\n                    inputRange: [0, 1],\n                    outputRange: [inactiveScale, 1]\n                })\n            }]\n        };\n        const animatedColor = this._shouldAnimateColor ? {\n            backgroundColor: animColor.interpolate({\n                inputRange: [0, 1],\n                outputRange: [inactiveColor, color]\n            })\n        } : {};\n\n        const dotContainerStyle = [\n            styles.sliderPaginationDotContainer,\n            containerStyle || {}\n        ];\n\n        const dotStyle = [\n            styles.sliderPaginationDot,\n            style || {},\n            (!active && inactiveStyle) || {},\n            animatedStyle,\n            animatedColor\n        ];\n\n        const onPress = tappable ? () => {\n            try {\n                const currentRef = carouselRef.current || carouselRef;\n                currentRef._snapToItem(currentRef._getPositionIndex(index));\n            } catch (error) {\n                console.warn(\n                    'react-native-snap-carousel | Pagination: ' +\n                    '`carouselRef` has to be a Carousel ref.\\n' + error\n                );\n            }\n        } : undefined;\n\n        return (\n            <TouchableOpacity\n              accessible={false}\n              style={dotContainerStyle}\n              activeOpacity={tappable ? activeOpacity : 1}\n              onPress={onPress}\n              delayPressIn={delayPressInDot}\n            >\n                <Animated.View style={dotStyle} />\n            </TouchableOpacity>\n        );\n    }\n}\n","import React, { PureComponent } from 'react';\nimport { I18nManager, Platform, View, ViewPropTypes } from 'react-native';\nimport PropTypes from 'prop-types';\nimport PaginationDot from './PaginationDot';\nimport styles from './Pagination.style';\n\nconst IS_IOS = Platform.OS === 'ios';\nconst IS_RTL = I18nManager.isRTL;\n\nexport default class Pagination extends PureComponent {\n\n    static propTypes = {\n        activeDotIndex: PropTypes.number.isRequired,\n        dotsLength: PropTypes.number.isRequired,\n        activeOpacity: PropTypes.number,\n        carouselRef: PropTypes.object,\n        containerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        dotColor: PropTypes.string,\n        dotContainerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        dotElement: PropTypes.element,\n        dotStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        inactiveDotColor: PropTypes.string,\n        inactiveDotElement: PropTypes.element,\n        inactiveDotOpacity: PropTypes.number,\n        inactiveDotScale: PropTypes.number,\n        inactiveDotStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        renderDots: PropTypes.func,\n        tappableDots: PropTypes.bool,\n        vertical: PropTypes.bool,\n        accessibilityLabel: PropTypes.string,\n        animatedDuration: PropTypes.number,\n        animatedFriction: PropTypes.number,\n        animatedTension: PropTypes.number,\n        delayPressInDot: PropTypes.number,\n    };\n\n    static defaultProps = {\n        inactiveDotOpacity: 0.5,\n        inactiveDotScale: 0.5,\n        tappableDots: false,\n        vertical: false,\n        animatedDuration: 250,\n        animatedFriction: 4,\n        animatedTension: 50,\n        delayPressInDot: 0,\n    }\n\n    constructor (props) {\n        super(props);\n\n        // Warnings\n        if ((props.dotColor && !props.inactiveDotColor) || (!props.dotColor && props.inactiveDotColor)) {\n            console.warn(\n                'react-native-snap-carousel | Pagination: ' +\n                'You need to specify both `dotColor` and `inactiveDotColor`'\n            );\n        }\n        if ((props.dotElement && !props.inactiveDotElement) || (!props.dotElement && props.inactiveDotElement)) {\n            console.warn(\n                'react-native-snap-carousel | Pagination: ' +\n                'You need to specify both `dotElement` and `inactiveDotElement`'\n            );\n        }\n        if (props.tappableDots && props.carouselRef === undefined) {\n            console.warn(\n                'react-native-snap-carousel | Pagination: ' +\n                'You must specify prop `carouselRef` when setting `tappableDots` to `true`'\n            );\n        }\n    }\n\n    _needsRTLAdaptations () {\n        const { vertical } = this.props;\n        return IS_RTL && !IS_IOS && !vertical;\n    }\n\n    get _activeDotIndex () {\n        const { activeDotIndex, dotsLength } = this.props;\n        return this._needsRTLAdaptations() ? dotsLength - activeDotIndex - 1 : activeDotIndex;\n    }\n\n    get dots () {\n        const {\n            activeOpacity,\n            carouselRef,\n            dotsLength,\n            dotColor,\n            dotContainerStyle,\n            dotElement,\n            dotStyle,\n            inactiveDotColor,\n            inactiveDotElement,\n            inactiveDotOpacity,\n            inactiveDotScale,\n            inactiveDotStyle,\n            renderDots,\n            tappableDots,\n            animatedDuration,\n            animatedFriction,\n            animatedTension,\n            delayPressInDot,\n        } = this.props;\n\n        if (renderDots) {\n            return renderDots(this._activeDotIndex, dotsLength, this);\n        }\n\n        const DefaultDot = <PaginationDot\n          carouselRef={carouselRef}\n          tappable={tappableDots && typeof carouselRef !== 'undefined'}\n          activeOpacity={activeOpacity}\n          color={dotColor}\n          containerStyle={dotContainerStyle}\n          style={dotStyle}\n          inactiveColor={inactiveDotColor}\n          inactiveOpacity={inactiveDotOpacity}\n          inactiveScale={inactiveDotScale}\n          inactiveStyle={inactiveDotStyle}\n          animatedDuration={animatedDuration}\n          animatedFriction={animatedFriction}\n          animatedTension={animatedTension}\n          delayPressInDot={delayPressInDot}\n        />;\n\n        const dots = [...Array(dotsLength).keys()].map(i => {\n            const isActive = i === this._activeDotIndex;\n            return React.cloneElement(\n                (isActive ? dotElement : inactiveDotElement) || DefaultDot,\n                {\n                    key: `pagination-dot-${i}`,\n                    active: isActive,\n                    index: i\n                }\n            );\n        });\n\n        return dots;\n    }\n\n    render () {\n        const { dotsLength, containerStyle, vertical, accessibilityLabel } = this.props;\n\n        if (!dotsLength || dotsLength < 2) {\n            return false;\n        }\n\n        const style = [\n            styles.sliderPagination,\n            { flexDirection: vertical ?\n                'column' :\n                (this._needsRTLAdaptations() ? 'row-reverse' : 'row')\n            },\n            containerStyle || {}\n        ];\n\n        return (\n            <View\n              pointerEvents={'box-none'}\n              style={style}\n              accessible={!!accessibilityLabel}\n              accessibilityLabel={accessibilityLabel}\n            >\n                { this.dots }\n            </View>\n        );\n    }\n}\n","import { StyleSheet } from 'react-native';\n\nexport default StyleSheet.create({\n    container: {\n        overflow: 'hidden',\n        alignItems: 'center',\n        justifyContent: 'center'\n    },\n    image: {\n        position: 'relative',\n        resizeMode: 'cover',\n        width: null,\n        height: null\n    },\n    loaderContainer: {\n        ...StyleSheet.absoluteFillObject,\n        alignItems: 'center',\n        justifyContent: 'center'\n    }\n});\n","// Parallax effect inspired by https://github.com/oblador/react-native-parallax/\n\nimport React, { Component } from 'react';\nimport { View, ViewPropTypes, Image, Animated, Easing, ActivityIndicator, findNodeHandle } from 'react-native';\nimport PropTypes from 'prop-types';\nimport styles from './ParallaxImage.style';\n\nexport default class ParallaxImage extends Component {\n\n    static propTypes = {\n        ...Image.propTypes,\n        carouselRef: PropTypes.object, // passed from <Carousel />\n        itemHeight: PropTypes.number, // passed from <Carousel />\n        itemWidth: PropTypes.number, // passed from <Carousel />\n        scrollPosition: PropTypes.object, // passed from <Carousel />\n        sliderHeight: PropTypes.number, // passed from <Carousel />\n        sliderWidth: PropTypes.number, // passed from <Carousel />\n        vertical: PropTypes.bool, // passed from <Carousel />\n        containerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        dimensions: PropTypes.shape({\n            width: PropTypes.number,\n            height: PropTypes.number\n        }),\n        fadeDuration: PropTypes.number,\n        parallaxFactor: PropTypes.number,\n        showSpinner: PropTypes.bool,\n        spinnerColor: PropTypes.string,\n        AnimatedImageComponent: PropTypes.oneOfType([\n            PropTypes.func,\n            PropTypes.object\n        ])\n    };\n\n    static defaultProps = {\n        containerStyle: {},\n        fadeDuration: 500,\n        parallaxFactor: 0.3,\n        showSpinner: true,\n        spinnerColor: 'rgba(0, 0, 0, 0.4)',\n        AnimatedImageComponent: Animated.Image\n    }\n\n    constructor (props) {\n        super(props);\n        this.state = {\n            offset: 0,\n            width: 0,\n            height: 0,\n            status: 1, // 1 -> loading; 2 -> loaded // 3 -> transition finished; 4 -> error\n            animOpacity: new Animated.Value(0)\n        };\n        this._onLoad = this._onLoad.bind(this);\n        this._onError = this._onError.bind(this);\n        this._measureLayout = this._measureLayout.bind(this);\n    }\n\n    setNativeProps (nativeProps) {\n        this._container.setNativeProps(nativeProps);\n    }\n\n    componentDidMount () {\n        this._mounted = true;\n\n        setTimeout(() => {\n            this._measureLayout();\n        }, 0);\n    }\n\n    componentWillUnmount () {\n        this._mounted = false;\n    }\n\n    _measureLayout () {\n        if (this._container) {\n            const {\n                dimensions,\n                vertical,\n                carouselRef,\n                sliderWidth,\n                sliderHeight,\n                itemWidth,\n                itemHeight\n            } = this.props;\n\n            if (carouselRef) {\n                this._container.measureLayout(\n                    findNodeHandle(carouselRef),\n                    (x, y, width, height, pageX, pageY) => {\n                        const offset = vertical ?\n                            y - ((sliderHeight - itemHeight) / 2) :\n                            x - ((sliderWidth - itemWidth) / 2);\n\n                        this.setState({\n                            offset: offset,\n                            width: dimensions && dimensions.width ?\n                                dimensions.width :\n                                Math.ceil(width),\n                            height: dimensions && dimensions.height ?\n                                dimensions.height :\n                                Math.ceil(height)\n                        });\n                    }\n                );\n            }\n        }\n    }\n\n    _onLoad (event) {\n        const { animOpacity } = this.state;\n        const { fadeDuration, onLoad } = this.props;\n\n        if (!this._mounted) {\n            return;\n        }\n\n        this.setState({ status: 2 });\n\n        if (onLoad) {\n            onLoad(event);\n        }\n\n        Animated.timing(animOpacity, {\n            toValue: 1,\n            duration: fadeDuration,\n            easing: Easing.out(Easing.quad),\n            isInteraction: false,\n            useNativeDriver: true\n        }).start(() => {\n            this.setState({ status: 3 });\n        });\n    }\n\n    // If arg is missing from method signature, it just won't be called\n    _onError (event) {\n        const { onError } = this.props;\n\n        this.setState({ status: 4 });\n\n        if (onError) {\n            onError(event);\n        }\n    }\n\n    get image () {\n        const { status, animOpacity, offset, width, height } = this.state;\n        const {\n            scrollPosition,\n            dimensions,\n            vertical,\n            sliderWidth,\n            sliderHeight,\n            parallaxFactor,\n            style,\n            AnimatedImageComponent,\n            ...other\n        } = this.props;\n\n        const parallaxPadding = (vertical ? height : width) * parallaxFactor;\n        const requiredStyles = { position: 'relative' };\n        const dynamicStyles = {\n            width: vertical ? width : width + parallaxPadding * 2,\n            height: vertical ? height + parallaxPadding * 2 : height,\n            opacity: animOpacity,\n            transform: scrollPosition ? [\n                {\n                    translateX: !vertical ? scrollPosition.interpolate({\n                        inputRange: [offset - sliderWidth, offset + sliderWidth],\n                        outputRange: [-parallaxPadding, parallaxPadding],\n                        extrapolate: 'clamp'\n                    }) : 0\n                },\n                {\n                    translateY: vertical ? scrollPosition.interpolate({\n                        inputRange: [offset - sliderHeight, offset + sliderHeight],\n                        outputRange: [-parallaxPadding, parallaxPadding],\n                        extrapolate: 'clamp'\n                    }) : 0\n                }\n            ] : []\n        };\n\n        return (\n            <AnimatedImageComponent\n              {...other}\n              style={[styles.image, style, requiredStyles, dynamicStyles]}\n              onLoad={this._onLoad}\n              onError={status !== 3 ? this._onError : undefined} // prevent infinite-loop bug\n            />\n        );\n    }\n\n    get spinner () {\n        const { status } = this.state;\n        const { showSpinner, spinnerColor } = this.props;\n\n        return status === 1 && showSpinner ? (\n            <View style={styles.loaderContainer}>\n                <ActivityIndicator\n                  size={'small'}\n                  color={spinnerColor}\n                  animating={true}\n                />\n            </View>\n        ) : false;\n    }\n\n    render () {\n        const { containerStyle } = this.props;\n\n        return (\n            <View\n              ref={(c) => { this._container = c; }}\n              pointerEvents={'none'}\n              style={[containerStyle, styles.container]}\n              onLayout={this._measureLayout}\n            >\n                { this.image }\n                { this.spinner }\n            </View>\n        );\n    }\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule shallowCompare\n */\n\n'use strict';\n\nvar shallowEqual = require('fbjs/lib/shallowEqual');\n\n/**\n * Does a shallow comparison for props and state.\n * See ReactComponentWithPureRenderMixin\n * See also https://facebook.github.io/react/docs/shallow-compare.html\n */\nfunction shallowCompare(instance, nextProps, nextState) {\n  return (\n    !shallowEqual(instance.props, nextProps) ||\n    !shallowEqual(instance.state, nextState)\n  );\n}\n\nmodule.exports = shallowCompare;\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;"],"sourceRoot":""}